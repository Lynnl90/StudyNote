、# 第十二章——线程

## 线程简介

### 什么是线程

现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时进行。

### 线程优先级

现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。

在 Java 线程中，通过一些整型成员变量 priority 来控制优先级，优先级的范围从 1 - 10，默认优先级是 5，优先级高的线程分配时间片的数量要多于优先级低的线程。

### Daemon 线程

Daemon 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个 JVM 不存在非 Daemon 线程的时候，JVM 将会退出，同时 JVM 中所有的 Daemon 线程都需要立即终止。可以通过调用 `Thread.setDaemon(true)`将线程设置为 Deamon 线程。

**注：**在构建 Daemon 线程时，不能依靠 finally 块中的内容来确保执行关闭或者清理资源的逻辑。

## 启动和终止线程

### 构造线程

一个新构造的线程对象是由其 parent 线程来进行空间分配的，而 child 线程继承了 parent 是否为 Daemon、优先级和加载资源的 contextClassLoader 以及可继承的 ThreadLocal，同时还会分配一个唯一的 ID 来标识这个 child 线程。

### 启动线程

线程 `start()` 方法的含义是：当前线程（即 parent 线程）同步告知 JVM，只要线程规划器空闲，应立即启动调用 `start()` 方法的线程。

### 中断

中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了招呼，其他线程通过调用该线程的 `interrupt()` 方法对其进行中断操作。

线程**通过检查自身是否被中断来进行响应**，线程通过方法 `isInterrupted()`  来进行判断是否被中断，也可以调用静态方法 `Thread.interrupted()` 对当前线程的中断标识进行复位。如果线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的 `isInterrupted()` 时依旧会返回 false。

在抛出 InterruptedException 之前，JVM 会先将该线程的中断标识位清除，此时调用 `isInterrupted()` 时依旧会返回 false。

## Java 线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：
* 协同式线程调度，线程的执行时间由线程本身来控制，线程把自己的工作执行完成之后，要主动通知系统切换到另外一个线程上。

* 抢占式线程调度，每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。

## 线程状态转换

Java 定义了 5 种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这 5 种状态分别如下：

* 新建（new），创建后尚未启动的线程处于这种状态

* 运行（Runnable），Runnble 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待 CPU 为它分配执行时间

* 无期限等待（Waiting），处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无期限的等待状态：

  * 没有设置 Timeout 参数的 Object.wait() 方法
  * 没有设置 Timeout 参数的 Thread.join() 方法
  * LockSupport.park() 方法

* 期限等待（Timed Waiting），处于这种状态的线程也不会被分配 CPU 执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们就会由系统自动唤醒。以下方法会让线程进入期限等待状态：
  * Thread.sleep();
  * 设置了 Timeout 参数的 Object.wait() 方法
  * 设置了 Timeout 参数的 Thread.join() 方法
  * LockSupport.parkNanos() 方法
  * LockSupport.parkUnil() 方法


* 阻塞（Blocked），线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

* 结束（Terminated），以终止线程的线程状态，线程已经结束执行。

## 线程间通信

任意线程对 Object（Object 由 synchronized 保护）的访问，首先要获得 Object 的监视器。如果获取失败，线程进入同步队列，线程状态变为 BLOCKED。当访问 Object 的 前驱（获得了锁的线程）释放了锁，则该释放操作唤醒在同步队列中的线程，使其重新**尝试**对监视器的获取。

### 等待 / 通知机制

1. 使用 `wait()`、`notify_()` 和 `notifyAll()` 时需要先对调用对象加锁

2. 调用 `wait()` 方法后，线程状态由 RUNNING 变为 WAITING，并将当前线程放置到对象的等待队列

3. `notify()` 或 `notifyAll()` 方法调用后，等待线程依旧不会从 `wait()` 方法返回，需要调用 `notify()` 或 `notifyAll()` 的线程释放锁之后，等待线程才有机会从 `wait()` 返回

4. `notify()` 将等待队列中的一个等待线程从等待队列中移到同步队列中，而 `notifyAll()` 方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由 WAITING 变为 BLOCKED

5. 从 `wait()` 方法返回的前提是获得了调用对象的锁。

### 等待 / 通知的经典范式

等待方（消费者）遵循如下原则：

1. 获取对象的锁
2. 如果条件不满足，那么调用对象的 `wait()` 方法，被通知后仍要检查条件
3. 条件满足则执行对应的逻辑

伪代码如下：
```java
synchronized(对象) {
  while(条件不满足) {
    对象.wait();
  }
  对应的处理逻辑
}
```

通知方（生产者）遵循如下原则：

1. 获取对象的锁
2. 改变条件
3. 通知所有等待在对象上的线程

伪代码如下：
```Java
synchronized (对象) {
  改变条件
  对象.notifyAll();
}
```

### `Thread.join()` 的使用

如果一个线程 A 执行了 `thread.join()` 语句，其含义是：当前线程 A 等待 thread 线程终止之后才从 `thread.join()` 返回。
