# 第五章—— Java 中的锁

## Lock 接口

锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发地访问共享资源，比如读写锁）

Lock 的使用方式

```Java
Lock lock = new ReentrantLock();
lock.lock();
try {
} finally {
  lock.unlock();
}
```

在 finally 块中释放锁，目的是保证在获取到锁之后，最终能够被释放。不要将获取锁的过程写在 try 块中，因为如果在获取锁（自定义锁的实现） 时发生了异常，异常抛出的同时，也会导致锁的无故释放。

Lock 接口提供的 synchronized 关键字所不具备的主要特性如下：

* 尝试非阻塞地获取锁，当前线程尝试获取锁，如果这一时刻没有被其他线程获取到，则成功获取并持有锁。

* 能被中断地获取锁，与 synchronized 不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常会被抛出，**同时锁会被释放**

* 超时获取锁，在指定的截至时间之前获取锁，如果截至时间到了仍旧无法获取锁，则返回。

## 队列同步器

队列同步器 AbstratQueuedSynchronizer ，是用老构建锁或者其他同步组件的基础架构，它使用了一个 int 成员变量表示同步状态，通过内置的队列完成资源获取线程的排队工作。

同步器的主要使用方式是继承。

子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方式来提供自定义同步组件使用，同步器既可以支持独占式式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件。


### 队列同步器的实现分析

1. 同步队列

  同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入到同步队列，同时会阻塞当前线程，当同步状态刷新时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

  同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱节点和后继节点。

  同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部。

  同步队列遵循 FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继结点，而后继节点将会在获取同步状态时将自己设置为首结点。

  设置为尾结点的时候，涉及到线程同步，所以要使用 CAS 的方法设置尾结点。而设置头结点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用 CAS 来保证，它只需要将头结点设置为原结点的后继结点并断开原头节点的 next 引用即可。

2. 独占式同步状态获取与释放

  通过调用同步器的 acquire(int arg) 方法可以获取同步状态，该方法对中断不敏感，也就是由于线程获取同步状态失败后进入同步队列中，后续对线程进行操作时，线程不会从同步队列中移出。

  acquire(int arg) 的主要逻辑是：首先调用自定义同步器实现的 tryAcquire(int arg) 方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式 Node，EXCLUSIVE，同一时刻只能有一个线程成功获取到同步状态）并通过 addWaiter(Node node) 方法将该节点加入到同步队列的尾部，最后调用 acquireQueued(Node node,int arg) 方法，使得该节点以 “死循环” 的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或者阻塞线程被中断来实现。

  在释放同步状态时，同步器调用 tryRelease(int arg) 方法释放同步状态，然后唤醒头节点的后继节点。

3. 共享式同步状态获取和释放

  共享式获取和独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。

  通过调用同步器的 acquireShared(int arg) 方法可以共享式地获取同步状态。

4. 独占式超时获取同步状态

  通过调用同步器的 doAcquireNano(int arg,long nanosTimeout) 方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回 true，否则，返回 false。

## 重入锁

重入锁 ReentrantLock，支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。

## 读写锁

读写锁维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大的提升。
