# 集合类和数据结构

map、vector、set 和 列表是 Clojure 提供的基本数据结构。

以下是它们的字面量：

* `'(a b :name 12.5)` 列表
* `['a 'b :name 12.5]`  vector
* `{:name "Chas" :age 31}`  map
* `#{1 2 3}`  set

Clojure 的数据结构有两个特色：
1. 数据结构首先是一句抽象来用的，而不是依据具体的实现细节来用的。
2. 数据结构是不可改变的而且是持久的，两者对 Clojure 风格的函数式编程效率至关重要。

## Collection 集合

Clojure 中所有的数据结构都实现了 Collection 抽象。以下是 Collection 的一些函数：

* 用 conj 来添加一个元素到集合
  * 向量：加到最后面
  * 列表：加到最前面
* 用 seq 来获取集合顺序视图
* 用 count 来获取集合的元素个数
* 用 empty 来获取一个跟所提供集合类型一样的空集合
* 用 = 来判断两个或多个集合是否相等

conj 保证的是对于所有的集合它都能高效的插入。

## Sequence 序列

Sequence 接口定义了一个获取并且遍历各种集合的一个顺序视图的一种方法。

## 原子类型（Atom）

原子类型是 Clojure 最基本的引用类型；它实现的是同步、无须协调的、原子的“线比较再设值”的修改策略。因此，对于原子类型的修改操作都要阻塞直到这个修改完成，每个修改操作都是完全隔离的——自动隔离的，没有办法协调对于两个 atom 的修改。

使用 `swap!` 可以对原子类型进行修改操作，它接受要修改的原子类型，一个函数以及一些额外的参数作为参数，它把当前这个原子类型的状态修改成对传入函数的返回值。即 CAS 操作。

Clojure 还提供了一个 compare-and-set! 操作，来进行 CAS 操作。

reset!：不管 atom 现在的状态直接进行修改

## 观察器

观察器是在引用的状态发生改变的时候会被调用的函数

所有的引用类型一开始都是没有观察器的，可以在任何时间给它注册一个观察器或者移除一个观察器。一个观察器函数必须接受 4 个参数：key、发生改变的引用（一个 atom ref、agent 或者 var）、引用的旧状态以及现在的新状态。
