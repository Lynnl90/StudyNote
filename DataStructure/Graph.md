# 图 杂记

## 定义

图G由两个集合组成：一个由顶点（vertex）构成的有穷非空集合和一个由边（edge）构成的有穷允空集合。V(G)和E(G)分别表示图G的顶点集和边集，有时也用G=(V,E)表示图。

**无向图** 是表示边的两个顶点之间没有次序关系的图。

**有向图** 是表示边的顶点对有方向的图。

对图的**限制**：

1. 图中不能有从顶点i到其自身的边。

2. 同一条边在图中不能出现两次或两次以上。

**完全图** 是具有最多边数的图。

对于一个具有n个顶点的无向图，边数的最大值等于不同的无序顶点对(vi,vj)(其中 i != j)的数量，其值为：`n(n - 1)/2`，对于有n个顶点的有向图，边的条数最多为：`n(n - 1)`。

## 生成树

如果图 G 是连通的，那么从任意一个顶点出发进行深度优先遍历或广度优先遍历都能访问到图 G 中的所有顶点。

所以，可以通过 dfs 来构造深度优先生成树，通过 bfs 可以构造广度优先生成树。

### 最小生成树

1. **Kruskal 算法**

  通过每次向当前最小生成树 T 中加入一条边的方法构造最终的最小生成树 T。算法按照边的权值非递减的顺序选取，并加入 T 中。如果所选取的边与 T 中的边不行成环路，则这条边加入到 T 中。由于图是连通的，且具有 n 个顶点（n > 0），所以最终恰好选取 n - 1 条边加入到 T 中。

  为了检查一条新边加入后不产生环路，可以使用 union-find 操作。

  时间复杂度为 O(e*loge)

2. **Prim 算法**

  与 Kruskal 算法一样， Prim 算法通过每次增加一条边的方法构造一棵最小生成树。然而和 Kruskal 算法不同的是，在每一步，Prim 算法所选取的边集形成一棵树，而 Kruskal 算法所选取的边集形成一个森林。

  为了保证所加入的边不形成环路，要求在每一步锁选取的边（u,v）的两个顶点 u 和 v，只能有一个顶点在 T 中。

  时间复杂度为 O(n*2)

3. Sollin 算法

  与 Prim 算法和 Kruskal 算法不同，Sollin 算法在每一步为生成树 T 递归地选取若干条边。在每一步处理开始时，所选取的边与图中的所有 n 个顶点形成森林。在每一步处理过程中，为森林中的每颗树都选取一条边，所选取的边都是恰有一个顶点在树上且权值最小。由于森林中的两棵树可能选取了同一条边，所以需要去掉同一条边被多次选取的情况。在开始时，所选取的边集为空。当最后结果只有一棵树或者再没有边可供选取时，算法结束。
